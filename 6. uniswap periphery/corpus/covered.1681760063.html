<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/Users/souravsuman/Documents/Personal/Echidna/6. uniswap periphery/contracts/crytic/EchidnaUniV2Tester.sol</b>
<code>
   1 |     | <span class='unexecuted'>pragma solidity ^0.6.0;</span>
   2 |     | <span class='neutral'>import &quot;./Setup.sol&quot;;</span>
   3 | *r  | <span class='executed'></span>
   4 |     | <span class='neutral'>contract EchidnaUniV2Tester is Setup {</span>
   5 |     | <span class='neutral'>    using SafeMath for uint;</span>
   6 |     | <span class='neutral'>    event logUints(uint kBefore, uint kAfter);</span>
   7 | *   | <span class='executed'>    function testProvideLiquidityInvariants(uint amount1, uint amount2) public {</span>
   8 |     | <span class='neutral'>        //PRECONDITIONS:</span>
   9 | *   | <span class='executed'>        amount1 = _between(amount1, 1000, uint(-1));</span>
  10 | *   | <span class='executed'>        amount2 = _between(amount2, 1000, uint(-1));</span>
  11 | *   | <span class='executed'>        if(!complete) {</span>
  12 | *   | <span class='executed'>            _init(amount1,amount2);</span>
  13 |     | <span class='neutral'>        }</span>
  14 |     | <span class='neutral'>        </span>
  15 | *   | <span class='executed'>        uint pairBalanceBefore = testPair.balanceOf(address(user));</span>
  16 |     | <span class='neutral'>        </span>
  17 | *   | <span class='executed'>        (uint reserve1Before, uint reserve2Before) = UniswapV2Library.getReserves(address(factory), address(testToken1), address(testToken2));</span>
  18 |     | <span class='neutral'>        </span>
  19 | *   | <span class='executed'>        uint kBefore = reserve1Before * reserve2Before;</span>
  20 |     | <span class='neutral'>       </span>
  21 |     | <span class='neutral'>        //CALL:</span>
  22 |     | <span class='neutral'>        </span>
  23 | *   | <span class='executed'>        (bool success, ) = user.proxy(address(router),abi.encodeWithSelector(router.addLiquidity.selector, address(testToken1), address(testToken2), amount1, amount2, 0, 0, address(user), uint(-1)));</span>
  24 |     | <span class='neutral'>        </span>
  25 |     | <span class='neutral'>        //POSTCONDITIONS</span>
  26 |     | <span class='neutral'>       </span>
  27 | *   | <span class='executed'>        if (success) {</span>
  28 | *   | <span class='executed'>            (uint reserve1After, uint reserve2After) = UniswapV2Library.getReserves(address(factory), address(testToken1), address(testToken2));</span>
  29 | *   | <span class='executed'>            uint pairBalanceAfter = testPair.balanceOf(address(user));</span>
  30 | *   | <span class='executed'>            uint kAfter = reserve1After*reserve2After;</span>
  31 | *   | <span class='executed'>            assert(kBefore &lt; kAfter);</span>
  32 | *   | <span class='executed'>            assert(pairBalanceBefore &lt; pairBalanceAfter);</span>
  33 |     | <span class='neutral'>        }</span>
  34 |     | <span class='neutral'>       </span>
  35 |     | <span class='neutral'>        </span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'>   </span>
  38 | *r  | <span class='executed'>    function testSwapTokens(uint swapAmountIn) public {</span>
  39 |     | <span class='neutral'>       //PRECONDITIONS:</span>
  40 |     | <span class='neutral'></span>
  41 | *r  | <span class='executed'>       if(!complete) {</span>
  42 | *r  | <span class='executed'>            _init(swapAmountIn,swapAmountIn);</span>
  43 |     | <span class='neutral'>        }</span>
  44 |     | <span class='neutral'>        </span>
  45 | *r  | <span class='executed'>        address[] memory path = new address[](2);</span>
  46 | *r  | <span class='executed'>        path[0] = address(testToken1);</span>
  47 | *r  | <span class='executed'>        path[1] = address(testToken2);</span>
  48 |     | <span class='neutral'></span>
  49 | *r  | <span class='executed'>        uint prevBal1 = UniswapV2ERC20(path[0]).balanceOf(address(user));</span>
  50 | *r  | <span class='executed'>        uint prevBal2 = UniswapV2ERC20(path[1]).balanceOf(address(user));</span>
  51 |     | <span class='neutral'></span>
  52 | *r  | <span class='executed'>        require(prevBal1 &gt; 0);</span>
  53 | *   | <span class='executed'>        swapAmountIn = _between(swapAmountIn, 1, prevBal1);</span>
  54 | *   | <span class='executed'>        (uint reserve1Before, uint reserve2Before) = UniswapV2Library.getReserves(address(factory), address(testToken1), address(testToken2));</span>
  55 | *   | <span class='executed'>        uint kBefore = reserve1Before * reserve2Before; </span>
  56 |     | <span class='neutral'>        //CALL: </span>
  57 | *   | <span class='executed'>        (bool success, ) = user.proxy(address(router), abi.encodeWithSelector(router.swapExactTokensForTokens.selector, swapAmountIn,0,path,address(user),uint(-1)));</span>
  58 |     | <span class='neutral'>        //POSTCONDITIONS:</span>
  59 |     | <span class='neutral'>           </span>
  60 | *   | <span class='executed'>        if(success) {</span>
  61 | *   | <span class='executed'>            uint balance1After = UniswapV2ERC20(path[0]).balanceOf(address(user));</span>
  62 | *   | <span class='executed'>            uint balance2After  = UniswapV2ERC20(path[1]).balanceOf(address(user));</span>
  63 | *   | <span class='executed'>            (uint reserve1After, uint reserve2After) = UniswapV2Library.getReserves(address(factory), address(testToken1), address(testToken2));</span>
  64 | *   | <span class='executed'>            uint kAfter = reserve1After*reserve2After;</span>
  65 | *   | <span class='executed'>            emit logUints(kBefore, kAfter);</span>
  66 | *   | <span class='executed'>            assert(kBefore &lt;= kAfter); </span>
  67 | *   | <span class='executed'>            assert(prevBal2 &lt; balance2After);</span>
  68 | *   | <span class='executed'>            assert(prevBal1 &gt; balance1After);</span>
  69 |     | <span class='neutral'>            </span>
  70 |     | <span class='neutral'>        }</span>
  71 |     | <span class='neutral'>       </span>
  72 |     | <span class='neutral'>        </span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 | *r  | <span class='executed'>    function testRemoveLiquidityInvariants(uint lpAmount) public {</span>
  76 |     | <span class='neutral'>        //PRECONDITIONS:</span>
  77 |     | <span class='neutral'></span>
  78 | *r  | <span class='executed'>        uint pairBalanceBefore = testPair.balanceOf(address(user));</span>
  79 |     | <span class='neutral'>        //user needs some LP tokens to burn</span>
  80 | *r  | <span class='executed'>        require(pairBalanceBefore &gt; 0);</span>
  81 | *   | <span class='executed'>        lpAmount = _between(lpAmount, 1, pairBalanceBefore);</span>
  82 |     | <span class='neutral'>        </span>
  83 | *   | <span class='executed'>        (uint reserve1Before, uint reserve2Before) = UniswapV2Library.getReserves(address(factory), address(testToken1), address(testToken2));</span>
  84 |     | <span class='neutral'>        //need to provide more than min liquidity</span>
  85 | *   | <span class='executed'>        uint kBefore = reserve1Before * reserve2Before;</span>
  86 | *   | <span class='executed'>       (bool success1,) = user.proxy(address(testPair),abi.encodeWithSelector(testPair.approve.selector,address(router),uint(-1)));</span>
  87 | *   | <span class='executed'>        require(success1);</span>
  88 |     | <span class='neutral'>        //CALL:</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>        </span>
  91 | *   | <span class='executed'>        (bool success, ) = user.proxy(address(router),abi.encodeWithSelector(router.removeLiquidity.selector, address(testToken1), address(testToken2),lpAmount, 0, 0, address(user), uint(-1)));</span>
  92 |     | <span class='neutral'>        </span>
  93 |     | <span class='neutral'>        //POSTCONDITIONS</span>
  94 |     | <span class='neutral'>        </span>
  95 | *   | <span class='executed'>        if (success) {</span>
  96 | *   | <span class='executed'>            (uint reserve1After, uint reserve2After) = UniswapV2Library.getReserves(address(factory), address(testToken1), address(testToken2));</span>
  97 | *   | <span class='executed'>            uint pairBalanceAfter = testPair.balanceOf(address(user));</span>
  98 | *   | <span class='executed'>            uint kAfter = reserve1After*reserve2After;</span>
  99 | *   | <span class='executed'>            assert(kBefore &gt; kAfter);</span>
 100 | *   | <span class='executed'>            assert(pairBalanceBefore &gt; pairBalanceAfter);</span>
 101 |     | <span class='neutral'>        }</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /*</span>
 105 |     | <span class='neutral'>    Helper function, copied from UniswapV2Library, needed in testPathIndependenceForSwaps.</span>
 106 |     | <span class='neutral'>    */</span>
 107 | *r  | <span class='executed'>    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) </span>
 108 |     | <span class='neutral'>    {</span>
 109 | *r  | <span class='executed'>        require(amountIn &gt; 0, &#39;UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT&#39;);</span>
 110 | *r  | <span class='executed'>        require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#39;);</span>
 111 | *r  | <span class='executed'>        uint amountInWithFee = amountIn.mul(997);</span>
 112 | *r  | <span class='executed'>        uint numerator = amountInWithFee.mul(reserveOut);</span>
 113 | *   | <span class='executed'>        uint denominator = reserveIn.mul(1000).add(amountInWithFee);</span>
 114 | *   | <span class='executed'>        amountOut = numerator / denominator;</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    /*</span>
 118 |     | <span class='neutral'>    Helper function, copied from UniswapV2Library, needed in testPathIndependenceForSwaps.</span>
 119 |     | <span class='neutral'>    */</span>
 120 | *   | <span class='executed'>    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) </span>
 121 |     | <span class='neutral'>    {</span>
 122 | *   | <span class='executed'>        require(amountOut &gt; 0, &#39;UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT&#39;);</span>
 123 | *   | <span class='executed'>        require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#39;);</span>
 124 | *   | <span class='executed'>        uint numerator = reserveIn.mul(amountOut).mul(1000);</span>
 125 | *   | <span class='executed'>        uint denominator = reserveOut.sub(amountOut).mul(997);</span>
 126 | *   | <span class='executed'>        amountIn = (numerator / denominator).add(1);</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    /*</span>
 130 |     | <span class='neutral'>    Swapping x of testToken1 for y token of testToken2 and back should (roughly) give user x of testToken1.</span>
 131 |     | <span class='neutral'>    The following function checks this condition by assessing that the resulting x is no more than 3% from the original x.</span>
 132 |     | <span class='neutral'>    </span>
 133 |     | <span class='neutral'>    However, this condition may be false when the pool has roughly the same amount of A and B and user swaps minimal amount of tokens.</span>
 134 |     | <span class='neutral'>    For instance, if pool consists of:</span>
 135 |     | <span class='neutral'>    - 1000 A</span>
 136 |     | <span class='neutral'>    - 1500 B</span>
 137 |     | <span class='neutral'>    then user can swap 2 A for 2 B (1002 * 1497 = 1 499 994 &lt; 1 500 000 = k, so the user won&#39;t get 3 B).</span>
 138 |     | <span class='neutral'>    Then, while user swaps back 2 B in the pool, he will get only 1 A, which is 50% loss from initial 2 A. </span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    Similar situation may happen if the user pays for some constant amount of testToken2 more than he needs to.</span>
 141 |     | <span class='neutral'>    For instance, consider a pool with:</span>
 142 |     | <span class='neutral'>    - 20 000 of token A</span>
 143 |     | <span class='neutral'>    - 5 of token B</span>
 144 |     | <span class='neutral'>    Then, k = 100 000. If user pays 10 000 of A, we will get only 1 token B (since otherwise new k &lt; 100 000).</span>
 145 |     | <span class='neutral'>    Now, k = 120 000, and the pool consists of 30 000 A and 4 B. </span>
 146 |     | <span class='neutral'>    If he swaps back 1 B for A, he gets only 6 000 A back (pool consists of 5 B and 24 000 A and k stays the same).</span>
 147 |     | <span class='neutral'>    So, after the trades, he lost 4 000 of A, which is 40% of his initial balance.</span>
 148 |     | <span class='neutral'>    But this wouldn&#39;t happen if user swapped initially 5 000 of A for 1 B.</span>
 149 |     | <span class='neutral'>    </span>
 150 |     | <span class='neutral'>    To prevent such situations, the following function imposes following limits on the user&#39;s input:</span>
 151 |     | <span class='neutral'>    1. It has to be greater than MINIMUM_AMOUNT = 100.</span>
 152 |     | <span class='neutral'>    2. For some amount y of testToken2, it has to be minimal among all inputs giving the user y testTokens2 from the swap.</span>
 153 |     | <span class='neutral'>    */</span>
 154 | *r  | <span class='executed'>    function testPathIndependenceForSwaps(uint x) public</span>
 155 |     | <span class='neutral'>    {</span>
 156 |     | <span class='neutral'>        // PRECONDITIONS:</span>
 157 | *r  | <span class='executed'>        if (!complete) </span>
 158 | r   | <span class='reverted'>            _init(1_000_000_000, 1_000_000_000);</span>
 159 |     | <span class='neutral'></span>
 160 | *r  | <span class='executed'>         (uint reserve1, uint reserve2) = UniswapV2Library.getReserves(address(factory), address(testToken1), address(testToken2));</span>
 161 |     | <span class='neutral'>        // if reserve1 or reserve2 &lt;= 1, then we cannot even make a swap</span>
 162 | *r  | <span class='executed'>        require(reserve1 &gt; 1);</span>
 163 | *r  | <span class='executed'>        require(reserve2 &gt; 1);</span>
 164 |     | <span class='neutral'></span>
 165 | *r  | <span class='executed'>        uint MINIMUM_AMOUNT = 100;</span>
 166 | *r  | <span class='executed'>        uint userBalance1 = testToken1.balanceOf(address(user));</span>
 167 | *r  | <span class='executed'>        require(userBalance1 &gt; MINIMUM_AMOUNT);</span>
 168 |     | <span class='neutral'></span>
 169 | *r  | <span class='executed'>        x = _between(x, MINIMUM_AMOUNT, uint(-1) / 100); // uint(-1) / 100 needed in POSTCONDITIONS to avoid overflow</span>
 170 | *r  | <span class='executed'>        x = _between(x, MINIMUM_AMOUNT, userBalance1);</span>
 171 |     | <span class='neutral'>        </span>
 172 |     | <span class='neutral'>        // use optimal x - it makes no sense to pay more for a given amount of tokens than necessary</span>
 173 |     | <span class='neutral'>        // nor it makes sense to &quot;buy&quot; 0 tokens</span>
 174 |     | <span class='neutral'>        // scope created to prevent &quot;stack too deep&quot; error</span>
 175 |     | <span class='neutral'>        {</span>
 176 | *r  | <span class='executed'>            uint yOut = getAmountOut(x, reserve1, reserve2);</span>
 177 | *   | <span class='executed'>            if (yOut == 0)</span>
 178 | *   | <span class='executed'>                yOut = 1;</span>
 179 |     | <span class='neutral'>            // x can only decrease here</span>
 180 | *   | <span class='executed'>            x = getAmountIn(yOut, reserve1, reserve2);</span>
 181 |     | <span class='neutral'>        }</span>
 182 | *   | <span class='executed'>        address[] memory path12 = new address[](2);</span>
 183 | *   | <span class='executed'>        path12[0] = address(testToken1);</span>
 184 | *   | <span class='executed'>        path12[1] = address(testToken2);</span>
 185 | *   | <span class='executed'>        address[] memory path21 = new address[](2);</span>
 186 | *   | <span class='executed'>        path21[0] = address(testToken2);</span>
 187 | *   | <span class='executed'>        path21[1] = address(testToken1);</span>
 188 |     | <span class='neutral'>        </span>
 189 | *   | <span class='executed'>        bool success;</span>
 190 | *   | <span class='executed'>        bytes memory returnData;</span>
 191 | *   | <span class='executed'>        uint[] memory amounts;</span>
 192 | *   | <span class='executed'>        uint xOut;</span>
 193 | *   | <span class='executed'>        uint y;</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>        // CALLS:</span>
 196 | *   | <span class='executed'>        (success, returnData) = user.proxy(address(router), abi.encodeWithSelector(router.swapExactTokensForTokens.selector, x, 0, path12, address(user), uint(-1)));</span>
 197 | *   | <span class='executed'>        if (!success)</span>
 198 |     | <span class='unexecuted'>            return;</span>
 199 | *   | <span class='executed'>        amounts = abi.decode(returnData, (uint[]));</span>
 200 |     | <span class='neutral'>        // y should be the same as yOut computed previously</span>
 201 | *   | <span class='executed'>        y = amounts[1];</span>
 202 | *   | <span class='executed'>        (success, returnData) = user.proxy(address(router), abi.encodeWithSelector(router.swapExactTokensForTokens.selector, y, 0, path21, address(user), uint(-1)));</span>
 203 | *   | <span class='executed'>        if (!success)</span>
 204 |     | <span class='unexecuted'>            return;</span>
 205 | *   | <span class='executed'>        amounts = abi.decode(returnData, (uint[]));</span>
 206 | *   | <span class='executed'>        xOut = amounts[1];</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>        // POSTCONDITIONS:</span>
 209 | *   | <span class='executed'>        assert(x &gt; xOut); // user cannot get more than he gave</span>
 210 |     | <span class='neutral'>        // 100 * (x - xOut) will not overflow since we constrained x to be &lt; uint(-1) / 100 before</span>
 211 | *   | <span class='executed'>        assert((x - xOut) * 100 &lt;= 3 * x); // (x - xOut) / x &lt;= 0.03; no more than 3% loss of funds</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'>}</span>
 214 |     | <span class='neutral'>// echidna .  --contract EchidnaUniV2Tester --config contracts/crytic/config.yaml</span>

</code>
<br />

<b>/Users/souravsuman/Documents/Personal/Echidna/6. uniswap periphery/contracts/crytic/Setup.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.6.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import &quot;../uni-v2/UniswapV2Pair.sol&quot;;</span>
  4 |     | <span class='neutral'>import &quot;../uni-v2/UniswapV2ERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../uni-v2/UniswapV2Factory.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../libraries/UniswapV2Library.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../uni-v2/UniswapV2Router01.sol&quot;;</span>
  8 | *r  | <span class='executed'></span>
  9 |     | <span class='neutral'>contract Users {</span>
 10 | *r  | <span class='executed'>    function proxy(address target, bytes memory _calldata)</span>
 11 |     | <span class='neutral'>        public</span>
 12 | *r  | <span class='executed'>        returns (bool success, bytes memory returnData)</span>
 13 |     | <span class='neutral'>    {</span>
 14 | *r  | <span class='executed'>        (success, returnData) = address(target).call(_calldata);</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='unexecuted'></span>
 18 |     | <span class='neutral'>contract Setup {</span>
 19 |     | <span class='neutral'>    UniswapV2ERC20 testToken1;</span>
 20 |     | <span class='neutral'>    UniswapV2ERC20 testToken2;</span>
 21 |     | <span class='neutral'>    UniswapV2Pair testPair;</span>
 22 |     | <span class='neutral'>    UniswapV2Factory factory;</span>
 23 |     | <span class='neutral'>    UniswapV2Router01 router;</span>
 24 |     | <span class='neutral'>    Users user;</span>
 25 |     | <span class='neutral'>    bool complete;</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    constructor() public {</span>
 28 |     | <span class='unexecuted'>        testToken1 = new UniswapV2ERC20();</span>
 29 |     | <span class='unexecuted'>        testToken2 = new UniswapV2ERC20();</span>
 30 |     | <span class='unexecuted'>        factory = new UniswapV2Factory(address(this)); //this contract will be the fee setter</span>
 31 |     | <span class='unexecuted'>        router = new UniswapV2Router01(address(factory), address(0)); // we don&#39;t need to test WETH pairs for now</span>
 32 |     | <span class='unexecuted'>        address pair = factory.createPair(</span>
 33 |     | <span class='unexecuted'>            address(testToken1),</span>
 34 |     | <span class='unexecuted'>            address(testToken2)</span>
 35 |     | <span class='neutral'>        );</span>
 36 |     | <span class='unexecuted'>        testPair = UniswapV2Pair(pair);</span>
 37 |     | <span class='unexecuted'>        user = new Users();</span>
 38 |     | <span class='neutral'>        // Sort the test tokens we just created, for clarity when writing invariant tests later</span>
 39 |     | <span class='unexecuted'>        (address testTokenA, address testTokenB) = UniswapV2Library.sortTokens(address(testToken1), address(testToken2));</span>
 40 |     | <span class='unexecuted'>        testToken1 = UniswapV2ERC20(testTokenA);</span>
 41 |     | <span class='unexecuted'>        testToken2 = UniswapV2ERC20(testTokenB);</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 | *r  | <span class='executed'>    function _doApprovals() internal {</span>
 45 | *r  | <span class='executed'>        user.proxy(</span>
 46 | *r  | <span class='executed'>            address(testToken1),</span>
 47 | *r  | <span class='executed'>            abi.encodeWithSelector(</span>
 48 | *r  | <span class='executed'>                testToken1.approve.selector,</span>
 49 | *r  | <span class='executed'>                address(router),</span>
 50 | *r  | <span class='executed'>                uint256(-1)</span>
 51 |     | <span class='neutral'>            )</span>
 52 |     | <span class='neutral'>        );</span>
 53 | *r  | <span class='executed'>        user.proxy(</span>
 54 | *r  | <span class='executed'>            address(testToken2),</span>
 55 | *r  | <span class='executed'>            abi.encodeWithSelector(</span>
 56 | *r  | <span class='executed'>                testToken2.approve.selector,</span>
 57 | *r  | <span class='executed'>                address(router),</span>
 58 | *r  | <span class='executed'>                uint256(-1)</span>
 59 |     | <span class='neutral'>            )</span>
 60 |     | <span class='neutral'>        );</span>
 61 |     | <span class='neutral'>    }</span>
 62 |     | <span class='neutral'></span>
 63 | *r  | <span class='executed'>    function _init(uint256 amount1, uint256 amount2) internal {</span>
 64 | *r  | <span class='executed'>        testToken2.mint(address(user), amount2);</span>
 65 | *r  | <span class='executed'>        testToken1.mint(address(user), amount1);</span>
 66 | *r  | <span class='executed'>        _doApprovals();</span>
 67 | *r  | <span class='executed'>        complete = true;</span>
 68 |     | <span class='neutral'>    }</span>
 69 |     | <span class='neutral'></span>
 70 | *r  | <span class='executed'>    function _between(</span>
 71 |     | <span class='neutral'>        uint256 val,</span>
 72 |     | <span class='neutral'>        uint256 lower,</span>
 73 |     | <span class='neutral'>        uint256 upper</span>
 74 | *r  | <span class='executed'>    ) internal pure returns (uint256) {</span>
 75 | *r  | <span class='executed'>        return lower + (val % (upper - lower + 1));</span>
 76 |     | <span class='neutral'>    }</span>
 77 |     | <span class='neutral'>}</span>
 78 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/souravsuman/Documents/Personal/Echidna/6. uniswap periphery/contracts/interfaces/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>interface IERC20 {</span>
  4 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint value);</span>
  5 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint value);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
  8 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
  9 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 10 |     | <span class='neutral'>    function totalSupply() external view returns (uint);</span>
 11 |     | <span class='neutral'>    function balanceOf(address owner) external view returns (uint);</span>
 12 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function approve(address spender, uint value) external returns (bool);</span>
 15 |     | <span class='neutral'>    function transfer(address to, uint value) external returns (bool);</span>
 16 |     | <span class='neutral'>    function transferFrom(address from, address to, uint value) external returns (bool);</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/souravsuman/Documents/Personal/Echidna/6. uniswap periphery/contracts/interfaces/IUniswapV2Callee.sol</b>
<code>
 1 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
 2 |     | <span class='neutral'></span>
 3 |     | <span class='neutral'>interface IUniswapV2Callee {</span>
 4 |     | <span class='neutral'>    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;</span>
 5 |     | <span class='neutral'>}</span>
 6 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/souravsuman/Documents/Personal/Echidna/6. uniswap periphery/contracts/interfaces/IUniswapV2ERC20.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>interface IUniswapV2ERC20 {</span>
  4 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint value);</span>
  5 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint value);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function name() external pure returns (string memory);</span>
  8 |     | <span class='neutral'>    function symbol() external pure returns (string memory);</span>
  9 |     | <span class='neutral'>    function decimals() external pure returns (uint8);</span>
 10 |     | <span class='neutral'>    function totalSupply() external view returns (uint);</span>
 11 |     | <span class='neutral'>    function balanceOf(address owner) external view returns (uint);</span>
 12 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function approve(address spender, uint value) external returns (bool);</span>
 15 |     | <span class='neutral'>    function transfer(address to, uint value) external returns (bool);</span>
 16 |     | <span class='neutral'>    function transferFrom(address from, address to, uint value) external returns (bool);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function DOMAIN_SEPARATOR() external view returns (bytes32);</span>
 19 |     | <span class='neutral'>    function PERMIT_TYPEHASH() external pure returns (bytes32);</span>
 20 |     | <span class='neutral'>    function nonces(address owner) external view returns (uint);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;</span>
 23 |     | <span class='neutral'>}</span>
 24 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/souravsuman/Documents/Personal/Echidna/6. uniswap periphery/contracts/interfaces/IUniswapV2Factory.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>interface IUniswapV2Factory {</span>
  4 |     | <span class='neutral'>    event PairCreated(address indexed token0, address indexed token1, address pair, uint);</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>    function feeTo() external view returns (address);</span>
  7 |     | <span class='neutral'>    function feeToSetter() external view returns (address);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function getPair(address tokenA, address tokenB) external view returns (address pair);</span>
 10 |     | <span class='neutral'>    function allPairs(uint) external view returns (address pair);</span>
 11 |     | <span class='neutral'>    function allPairsLength() external view returns (uint);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function createPair(address tokenA, address tokenB) external returns (address pair);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function setFeeTo(address) external;</span>
 16 |     | <span class='neutral'>    function setFeeToSetter(address) external;</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/souravsuman/Documents/Personal/Echidna/6. uniswap periphery/contracts/interfaces/IUniswapV2Pair.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>interface IUniswapV2Pair {</span>
  4 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint value);</span>
  5 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint value);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function name() external pure returns (string memory);</span>
  8 |     | <span class='neutral'>    function symbol() external pure returns (string memory);</span>
  9 |     | <span class='neutral'>    function decimals() external pure returns (uint8);</span>
 10 |     | <span class='neutral'>    function totalSupply() external view returns (uint);</span>
 11 |     | <span class='neutral'>    function balanceOf(address owner) external view returns (uint);</span>
 12 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function approve(address spender, uint value) external returns (bool);</span>
 15 |     | <span class='neutral'>    function transfer(address to, uint value) external returns (bool);</span>
 16 |     | <span class='neutral'>    function transferFrom(address from, address to, uint value) external returns (bool);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function DOMAIN_SEPARATOR() external view returns (bytes32);</span>
 19 |     | <span class='neutral'>    function PERMIT_TYPEHASH() external pure returns (bytes32);</span>
 20 |     | <span class='neutral'>    function nonces(address owner) external view returns (uint);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    event Mint(address indexed sender, uint amount0, uint amount1);</span>
 25 |     | <span class='neutral'>    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);</span>
 26 |     | <span class='neutral'>    event Swap(</span>
 27 |     | <span class='neutral'>        address indexed sender,</span>
 28 |     | <span class='neutral'>        uint amount0In,</span>
 29 |     | <span class='neutral'>        uint amount1In,</span>
 30 |     | <span class='neutral'>        uint amount0Out,</span>
 31 |     | <span class='neutral'>        uint amount1Out,</span>
 32 |     | <span class='neutral'>        address indexed to</span>
 33 |     | <span class='neutral'>    );</span>
 34 |     | <span class='neutral'>    event Sync(uint112 reserve0, uint112 reserve1);</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    function MINIMUM_LIQUIDITY() external pure returns (uint);</span>
 37 |     | <span class='neutral'>    function factory() external view returns (address);</span>
 38 |     | <span class='neutral'>    function token0() external view returns (address);</span>
 39 |     | <span class='neutral'>    function token1() external view returns (address);</span>
 40 |     | <span class='neutral'>    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);</span>
 41 |     | <span class='neutral'>    function price0CumulativeLast() external view returns (uint);</span>
 42 |     | <span class='neutral'>    function price1CumulativeLast() external view returns (uint);</span>
 43 |     | <span class='neutral'>    function kLast() external view returns (uint);</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    function mint(address to) external returns (uint liquidity);</span>
 46 |     | <span class='neutral'>    function burn(address to) external returns (uint amount0, uint amount1);</span>
 47 |     | <span class='neutral'>    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;</span>
 48 |     | <span class='neutral'>    function skim(address to) external;</span>
 49 |     | <span class='neutral'>    function sync() external;</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    function initialize(address, address) external;</span>
 52 |     | <span class='neutral'>}</span>
 53 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/souravsuman/Documents/Personal/Echidna/6. uniswap periphery/contracts/interfaces/IUniswapV2Router01.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity &gt;=0.6.2;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>interface IUniswapV2Router01 {</span>
  4 |     | <span class='neutral'>    function factory() external pure returns (address);</span>
  5 |     | <span class='neutral'>    function WETH() external pure returns (address);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function addLiquidity(</span>
  8 |     | <span class='neutral'>        address tokenA,</span>
  9 |     | <span class='neutral'>        address tokenB,</span>
 10 |     | <span class='neutral'>        uint amountADesired,</span>
 11 |     | <span class='neutral'>        uint amountBDesired,</span>
 12 |     | <span class='neutral'>        uint amountAMin,</span>
 13 |     | <span class='neutral'>        uint amountBMin,</span>
 14 |     | <span class='neutral'>        address to,</span>
 15 |     | <span class='neutral'>        uint deadline</span>
 16 |     | <span class='neutral'>    ) external returns (uint amountA, uint amountB, uint liquidity);</span>
 17 |     | <span class='neutral'>    function addLiquidityETH(</span>
 18 |     | <span class='neutral'>        address token,</span>
 19 |     | <span class='neutral'>        uint amountTokenDesired,</span>
 20 |     | <span class='neutral'>        uint amountTokenMin,</span>
 21 |     | <span class='neutral'>        uint amountETHMin,</span>
 22 |     | <span class='neutral'>        address to,</span>
 23 |     | <span class='neutral'>        uint deadline</span>
 24 |     | <span class='neutral'>    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);</span>
 25 |     | <span class='neutral'>    function removeLiquidity(</span>
 26 |     | <span class='neutral'>        address tokenA,</span>
 27 |     | <span class='neutral'>        address tokenB,</span>
 28 |     | <span class='neutral'>        uint liquidity,</span>
 29 |     | <span class='neutral'>        uint amountAMin,</span>
 30 |     | <span class='neutral'>        uint amountBMin,</span>
 31 |     | <span class='neutral'>        address to,</span>
 32 |     | <span class='neutral'>        uint deadline</span>
 33 |     | <span class='neutral'>    ) external returns (uint amountA, uint amountB);</span>
 34 |     | <span class='neutral'>    function removeLiquidityETH(</span>
 35 |     | <span class='neutral'>        address token,</span>
 36 |     | <span class='neutral'>        uint liquidity,</span>
 37 |     | <span class='neutral'>        uint amountTokenMin,</span>
 38 |     | <span class='neutral'>        uint amountETHMin,</span>
 39 |     | <span class='neutral'>        address to,</span>
 40 |     | <span class='neutral'>        uint deadline</span>
 41 |     | <span class='neutral'>    ) external returns (uint amountToken, uint amountETH);</span>
 42 |     | <span class='neutral'>    function removeLiquidityWithPermit(</span>
 43 |     | <span class='neutral'>        address tokenA,</span>
 44 |     | <span class='neutral'>        address tokenB,</span>
 45 |     | <span class='neutral'>        uint liquidity,</span>
 46 |     | <span class='neutral'>        uint amountAMin,</span>
 47 |     | <span class='neutral'>        uint amountBMin,</span>
 48 |     | <span class='neutral'>        address to,</span>
 49 |     | <span class='neutral'>        uint deadline,</span>
 50 |     | <span class='neutral'>        bool approveMax, uint8 v, bytes32 r, bytes32 s</span>
 51 |     | <span class='neutral'>    ) external returns (uint amountA, uint amountB);</span>
 52 |     | <span class='neutral'>    function removeLiquidityETHWithPermit(</span>
 53 |     | <span class='neutral'>        address token,</span>
 54 |     | <span class='neutral'>        uint liquidity,</span>
 55 |     | <span class='neutral'>        uint amountTokenMin,</span>
 56 |     | <span class='neutral'>        uint amountETHMin,</span>
 57 |     | <span class='neutral'>        address to,</span>
 58 |     | <span class='neutral'>        uint deadline,</span>
 59 |     | <span class='neutral'>        bool approveMax, uint8 v, bytes32 r, bytes32 s</span>
 60 |     | <span class='neutral'>    ) external returns (uint amountToken, uint amountETH);</span>
 61 |     | <span class='neutral'>    function swapExactTokensForTokens(</span>
 62 |     | <span class='neutral'>        uint amountIn,</span>
 63 |     | <span class='neutral'>        uint amountOutMin,</span>
 64 |     | <span class='neutral'>        address[] calldata path,</span>
 65 |     | <span class='neutral'>        address to,</span>
 66 |     | <span class='neutral'>        uint deadline</span>
 67 |     | <span class='neutral'>    ) external returns (uint[] memory amounts);</span>
 68 |     | <span class='neutral'>    function swapTokensForExactTokens(</span>
 69 |     | <span class='neutral'>        uint amountOut,</span>
 70 |     | <span class='neutral'>        uint amountInMax,</span>
 71 |     | <span class='neutral'>        address[] calldata path,</span>
 72 |     | <span class='neutral'>        address to,</span>
 73 |     | <span class='neutral'>        uint deadline</span>
 74 |     | <span class='neutral'>    ) external returns (uint[] memory amounts);</span>
 75 |     | <span class='neutral'>    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)</span>
 76 |     | <span class='neutral'>        external</span>
 77 |     | <span class='neutral'>        payable</span>
 78 |     | <span class='neutral'>        returns (uint[] memory amounts);</span>
 79 |     | <span class='neutral'>    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)</span>
 80 |     | <span class='neutral'>        external</span>
 81 |     | <span class='neutral'>        returns (uint[] memory amounts);</span>
 82 |     | <span class='neutral'>    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)</span>
 83 |     | <span class='neutral'>        external</span>
 84 |     | <span class='neutral'>        returns (uint[] memory amounts);</span>
 85 |     | <span class='neutral'>    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)</span>
 86 |     | <span class='neutral'>        external</span>
 87 |     | <span class='neutral'>        payable</span>
 88 |     | <span class='neutral'>        returns (uint[] memory amounts);</span>
 89 |     | <span class='neutral'></span>
 90 |     | <span class='neutral'>    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);</span>
 91 |     | <span class='neutral'>    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);</span>
 92 |     | <span class='neutral'>    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);</span>
 93 |     | <span class='neutral'>    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);</span>
 94 |     | <span class='neutral'>    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);</span>
 95 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/souravsuman/Documents/Personal/Echidna/6. uniswap periphery/contracts/interfaces/IWETH.sol</b>
<code>
 1 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
 2 |     | <span class='neutral'></span>
 3 |     | <span class='neutral'>interface IWETH {</span>
 4 |     | <span class='neutral'>    function deposit() external payable;</span>
 5 |     | <span class='neutral'>    function transfer(address to, uint value) external returns (bool);</span>
 6 |     | <span class='neutral'>    function withdraw(uint) external;</span>
 7 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/souravsuman/Documents/Personal/Echidna/6. uniswap periphery/contracts/libraries/Math.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.6.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>// a library for performing various math operations</span>
  4 |     | <span class='unexecuted'></span>
  5 |     | <span class='neutral'>library Math {</span>
  6 | *   | <span class='executed'>    function min(uint x, uint y) internal pure returns (uint z) {</span>
  7 | *   | <span class='executed'>        z = x &lt; y ? x : y;</span>
  8 |     | <span class='neutral'>    }</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)</span>
 11 | *   | <span class='executed'>    function sqrt(uint y) internal pure returns (uint z) {</span>
 12 | *   | <span class='executed'>        if (y &gt; 3) {</span>
 13 | *   | <span class='executed'>            z = y;</span>
 14 | *   | <span class='executed'>            uint x = y / 2 + 1;</span>
 15 | *   | <span class='executed'>            while (x &lt; z) {</span>
 16 | *   | <span class='executed'>                z = x;</span>
 17 | *   | <span class='executed'>                x = (y / x + x) / 2;</span>
 18 |     | <span class='neutral'>            }</span>
 19 |     | <span class='unexecuted'>        } else if (y != 0) {</span>
 20 |     | <span class='unexecuted'>            z = 1;</span>
 21 |     | <span class='neutral'>        }</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'>}</span>
 24 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/souravsuman/Documents/Personal/Echidna/6. uniswap periphery/contracts/libraries/SafeMath.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity &gt;=0.5.16;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)</span>
  4 |     | <span class='unexecuted'></span>
  5 |     | <span class='neutral'>library SafeMath {</span>
  6 | *r  | <span class='executed'>    function add(uint x, uint y) internal pure returns (uint z) {</span>
  7 | *r  | <span class='executed'>        require((z = x + y) &gt;= x, &#39;ds-math-add-overflow&#39;);</span>
  8 |     | <span class='neutral'>    }</span>
  9 |     | <span class='neutral'></span>
 10 | *   | <span class='executed'>    function sub(uint x, uint y) internal pure returns (uint z) {</span>
 11 | *   | <span class='executed'>        require((z = x - y) &lt;= x, &#39;ds-math-sub-underflow&#39;);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 | *r  | <span class='executed'>    function mul(uint x, uint y) internal pure returns (uint z) {</span>
 15 | *r  | <span class='executed'>        require(y == 0 || (z = x * y) / y == x, &#39;ds-math-mul-overflow&#39;);</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/souravsuman/Documents/Personal/Echidna/6. uniswap periphery/contracts/libraries/TransferHelper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.6.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='unexecuted'>// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false</span>
  6 |     | <span class='neutral'>library TransferHelper {</span>
  7 |     | <span class='neutral'>    function safeApprove(</span>
  8 |     | <span class='neutral'>        address token,</span>
  9 |     | <span class='neutral'>        address to,</span>
 10 |     | <span class='neutral'>        uint256 value</span>
 11 |     | <span class='neutral'>    ) internal {</span>
 12 |     | <span class='neutral'>        // bytes4(keccak256(bytes(&#39;approve(address,uint256)&#39;)));</span>
 13 |     | <span class='neutral'>        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));</span>
 14 |     | <span class='neutral'>        require(</span>
 15 |     | <span class='neutral'>            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),</span>
 16 |     | <span class='neutral'>            &#39;TransferHelper::safeApprove: approve failed&#39;</span>
 17 |     | <span class='neutral'>        );</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    function safeTransfer(</span>
 21 |     | <span class='neutral'>        address token,</span>
 22 |     | <span class='neutral'>        address to,</span>
 23 |     | <span class='neutral'>        uint256 value</span>
 24 |     | <span class='neutral'>    ) internal {</span>
 25 |     | <span class='neutral'>        // bytes4(keccak256(bytes(&#39;transfer(address,uint256)&#39;)));</span>
 26 |     | <span class='unexecuted'>        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));</span>
 27 |     | <span class='unexecuted'>        require(</span>
 28 |     | <span class='unexecuted'>            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),</span>
 29 |     | <span class='neutral'>            &#39;TransferHelper::safeTransfer: transfer failed&#39;</span>
 30 |     | <span class='neutral'>        );</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 | *   | <span class='executed'>    function safeTransferFrom(</span>
 34 |     | <span class='neutral'>        address token,</span>
 35 |     | <span class='neutral'>        address from,</span>
 36 |     | <span class='neutral'>        address to,</span>
 37 |     | <span class='neutral'>        uint256 value</span>
 38 |     | <span class='neutral'>    ) internal {</span>
 39 |     | <span class='neutral'>        // bytes4(keccak256(bytes(&#39;transferFrom(address,address,uint256)&#39;)));</span>
 40 | *   | <span class='executed'>        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));</span>
 41 | *   | <span class='executed'>        require(</span>
 42 | *   | <span class='executed'>            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),</span>
 43 |     | <span class='neutral'>            &#39;TransferHelper::transferFrom: transferFrom failed&#39;</span>
 44 |     | <span class='neutral'>        );</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>    function safeTransferETH(address to, uint256 value) internal {</span>
 48 |     | <span class='unexecuted'>        (bool success, ) = to.call{value: value}(new bytes(0));</span>
 49 |     | <span class='unexecuted'>        require(success, &#39;TransferHelper::safeTransferETH: ETH transfer failed&#39;);</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/souravsuman/Documents/Personal/Echidna/6. uniswap periphery/contracts/libraries/UQ112x112.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.6.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>// range: [0, 2**112 - 1]</span>
  6 |     | <span class='neutral'>// resolution: 1 / 2**112</span>
  7 |     | <span class='unexecuted'></span>
  8 |     | <span class='neutral'>library UQ112x112 {</span>
  9 | *   | <span class='executed'>    uint224 constant Q112 = 2**112;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    // encode a uint112 as a UQ112x112</span>
 12 | *   | <span class='executed'>    function encode(uint112 y) internal pure returns (uint224 z) {</span>
 13 | *   | <span class='executed'>        z = uint224(y) * Q112; // never overflows</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    // divide a UQ112x112 by a uint112, returning a UQ112x112</span>
 17 | *   | <span class='executed'>    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {</span>
 18 | *   | <span class='executed'>        z = x / uint224(y);</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/souravsuman/Documents/Personal/Echidna/6. uniswap periphery/contracts/libraries/UniswapV2Library.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import &#39;../interfaces/IUniswapV2Pair.sol&#39;;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./SafeMath.sol&quot;;</span>
  6 |     | <span class='unexecuted'></span>
  7 |     | <span class='neutral'>library UniswapV2Library {</span>
  8 |     | <span class='neutral'>    using SafeMath for uint;</span>
  9 |     | <span class='neutral'>    </span>
 10 |     | <span class='neutral'>    // returns sorted token addresses, used to handle return values from pairs sorted in this order</span>
 11 | *r  | <span class='executed'>    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {</span>
 12 | *r  | <span class='executed'>        require(tokenA != tokenB, &#39;UniswapV2Library: IDENTICAL_ADDRESSES&#39;);</span>
 13 | *r  | <span class='executed'>        (token0, token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span>
 14 | *r  | <span class='executed'>        require(token0 != address(0), &#39;UniswapV2Library: ZERO_ADDRESS&#39;);</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    // calculates the CREATE2 address for a pair without making any external calls</span>
 18 | *r  | <span class='executed'>    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {</span>
 19 | *r  | <span class='executed'>        (address token0, address token1) = sortTokens(tokenA, tokenB);</span>
 20 | *r  | <span class='executed'>        pair = address(uint160(uint(keccak256(abi.encodePacked(</span>
 21 |     | <span class='neutral'>                hex&#39;ff&#39;,</span>
 22 | *r  | <span class='executed'>                factory,</span>
 23 | *r  | <span class='executed'>                keccak256(abi.encodePacked(token0, token1)),</span>
 24 |     | <span class='neutral'>                hex&#39;531622abdfb371accc3ef7183f26464b751744513c84f60ed118d68e2e727916&#39;</span>
 25 |     | <span class='neutral'>                //hex&#39;96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f&#39; // init code hash</span>
 26 |     | <span class='neutral'>            )))));</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    // fetches and sorts the reserves for a pair</span>
 30 | *r  | <span class='executed'>    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {</span>
 31 | *r  | <span class='executed'>        (address token0,) = sortTokens(tokenA, tokenB);</span>
 32 | *r  | <span class='executed'>        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();</span>
 33 | *r  | <span class='executed'>        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset</span>
 37 | *   | <span class='executed'>    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {</span>
 38 | *   | <span class='executed'>        require(amountA &gt; 0, &#39;UniswapV2Library: INSUFFICIENT_AMOUNT&#39;);</span>
 39 | *   | <span class='executed'>        require(reserveA &gt; 0 &amp;&amp; reserveB &gt; 0, &#39;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#39;);</span>
 40 | *   | <span class='executed'>        amountB = amountA.mul(reserveB) / reserveA;</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset</span>
 44 | *   | <span class='executed'>    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {</span>
 45 | *   | <span class='executed'>        require(amountIn &gt; 0, &#39;UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT&#39;);</span>
 46 | *   | <span class='executed'>        require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#39;);</span>
 47 | *   | <span class='executed'>        uint amountInWithFee = amountIn.mul(997);</span>
 48 | *   | <span class='executed'>        uint numerator = amountInWithFee.mul(reserveOut);</span>
 49 | *   | <span class='executed'>        uint denominator = reserveIn.mul(1000).add(amountInWithFee);</span>
 50 | *   | <span class='executed'>        amountOut = numerator / denominator;</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset</span>
 54 |     | <span class='unexecuted'>    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {</span>
 55 |     | <span class='unexecuted'>        require(amountOut &gt; 0, &#39;UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT&#39;);</span>
 56 |     | <span class='unexecuted'>        require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#39;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#39;);</span>
 57 |     | <span class='unexecuted'>        uint numerator = reserveIn.mul(amountOut).mul(1000);</span>
 58 |     | <span class='unexecuted'>        uint denominator = reserveOut.sub(amountOut).mul(997);</span>
 59 |     | <span class='unexecuted'>        amountIn = (numerator / denominator).add(1);</span>
 60 |     | <span class='neutral'>    }</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>    // performs chained getAmountOut calculations on any number of pairs</span>
 63 | *   | <span class='executed'>    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {</span>
 64 | *   | <span class='executed'>        require(path.length &gt;= 2, &#39;UniswapV2Library: INVALID_PATH&#39;);</span>
 65 | *   | <span class='executed'>        amounts = new uint[](path.length);</span>
 66 | *   | <span class='executed'>        amounts[0] = amountIn;</span>
 67 | *   | <span class='executed'>        for (uint i; i &lt; path.length - 1; i++) {</span>
 68 | *   | <span class='executed'>            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);</span>
 69 | *   | <span class='executed'>            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);</span>
 70 |     | <span class='neutral'>        }</span>
 71 |     | <span class='neutral'>    }</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='neutral'>    // performs chained getAmountIn calculations on any number of pairs</span>
 74 |     | <span class='unexecuted'>    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {</span>
 75 |     | <span class='unexecuted'>        require(path.length &gt;= 2, &#39;UniswapV2Library: INVALID_PATH&#39;);</span>
 76 |     | <span class='unexecuted'>        amounts = new uint[](path.length);</span>
 77 |     | <span class='unexecuted'>        amounts[amounts.length - 1] = amountOut;</span>
 78 |     | <span class='unexecuted'>        for (uint i = path.length - 1; i &gt; 0; i--) {</span>
 79 |     | <span class='unexecuted'>            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);</span>
 80 |     | <span class='unexecuted'>            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);</span>
 81 |     | <span class='neutral'>        }</span>
 82 |     | <span class='neutral'>    }</span>
 83 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/souravsuman/Documents/Personal/Echidna/6. uniswap periphery/contracts/test/ERC20.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.6.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import &#39;../uni-v2/UniswapV2ERC20.sol&#39;;</span>
  4 |     | <span class='unexecuted'></span>
  5 |     | <span class='neutral'>contract ERC20 is UniswapV2ERC20 {</span>
  6 |     | <span class='unexecuted'>    constructor(uint _totalSupply) public {</span>
  7 |     | <span class='unexecuted'>        _mint(msg.sender, _totalSupply);</span>
  8 |     | <span class='neutral'>    }</span>
  9 |     | <span class='neutral'>}</span>
 10 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/souravsuman/Documents/Personal/Echidna/6. uniswap periphery/contracts/uni-v2/UniswapV2ERC20.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.6.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import &#39;../interfaces/IUniswapV2ERC20.sol&#39;;</span>
  4 |     | <span class='neutral'>import &#39;../libraries/SafeMath.sol&#39;;</span>
  5 | *r  | <span class='executed'></span>
  6 |     | <span class='neutral'>contract UniswapV2ERC20 {</span>
  7 |     | <span class='neutral'>    using SafeMath for uint;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    string public constant name = &#39;Uniswap V2&#39;;</span>
 10 |     | <span class='unexecuted'>    string public constant symbol = &#39;UNI-V2&#39;;</span>
 11 |     | <span class='unexecuted'>    uint8 public constant decimals = 18;</span>
 12 |     | <span class='unexecuted'>    uint  public totalSupply;</span>
 13 | *r  | <span class='executed'>    mapping(address =&gt; uint) public balanceOf;</span>
 14 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; uint)) public allowance;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    bytes32 public DOMAIN_SEPARATOR;</span>
 17 |     | <span class='neutral'>    // keccak256(&quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;);</span>
 18 |     | <span class='unexecuted'>    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;</span>
 19 |     | <span class='unexecuted'>    mapping(address =&gt; uint) public nonces;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint value);</span>
 22 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    constructor() public {</span>
 25 |     | <span class='unexecuted'>        uint chainId;</span>
 26 |     | <span class='neutral'>        assembly {</span>
 27 |     | <span class='unexecuted'>            chainId := chainid()</span>
 28 |     | <span class='neutral'>        } </span>
 29 |     | <span class='unexecuted'>        DOMAIN_SEPARATOR = keccak256(</span>
 30 |     | <span class='unexecuted'>            abi.encode(</span>
 31 |     | <span class='unexecuted'>                keccak256(&#39;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&#39;),</span>
 32 |     | <span class='unexecuted'>                keccak256(bytes(name)),</span>
 33 |     | <span class='unexecuted'>                keccak256(bytes(&#39;1&#39;)),</span>
 34 |     | <span class='unexecuted'>                chainId,</span>
 35 |     | <span class='unexecuted'>                address(this)</span>
 36 |     | <span class='neutral'>            )</span>
 37 |     | <span class='neutral'>        );</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 | *r  | <span class='executed'>    function _mint(address to, uint value) internal {</span>
 41 | *r  | <span class='executed'>        totalSupply = totalSupply.add(value);</span>
 42 | *r  | <span class='executed'>        balanceOf[to] = balanceOf[to].add(value);</span>
 43 | *r  | <span class='executed'>        emit Transfer(address(0), to, value);</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'></span>
 46 | *   | <span class='executed'>    function _burn(address from, uint value) internal {</span>
 47 | *   | <span class='executed'>        balanceOf[from] = balanceOf[from].sub(value);</span>
 48 | *   | <span class='executed'>        totalSupply = totalSupply.sub(value);</span>
 49 | *   | <span class='executed'>        emit Transfer(from, address(0), value);</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'></span>
 52 | *r  | <span class='executed'>    function _approve(address owner, address spender, uint value) private {</span>
 53 | *r  | <span class='executed'>        allowance[owner][spender] = value;</span>
 54 | *r  | <span class='executed'>        emit Approval(owner, spender, value);</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'></span>
 57 | *   | <span class='executed'>    function _transfer(address from, address to, uint value) private {</span>
 58 | *   | <span class='executed'>        balanceOf[from] = balanceOf[from].sub(value);</span>
 59 | *   | <span class='executed'>        balanceOf[to] = balanceOf[to].add(value);</span>
 60 | *   | <span class='executed'>        emit Transfer(from, to, value);</span>
 61 |     | <span class='neutral'>    }</span>
 62 |     | <span class='neutral'></span>
 63 | *r  | <span class='executed'>    function approve(address spender, uint value) external returns (bool) {</span>
 64 | *r  | <span class='executed'>        _approve(msg.sender, spender, value);</span>
 65 | *r  | <span class='executed'>        return true;</span>
 66 |     | <span class='neutral'>    }</span>
 67 |     | <span class='neutral'></span>
 68 | *   | <span class='executed'>    function transfer(address to, uint value) external virtual returns (bool) {</span>
 69 | *   | <span class='executed'>        _transfer(msg.sender, to, value);</span>
 70 | *   | <span class='executed'>        return true;</span>
 71 |     | <span class='neutral'>    }</span>
 72 |     | <span class='neutral'></span>
 73 | *   | <span class='executed'>    function transferFrom(address from, address to, uint value) external returns (bool) {</span>
 74 | *   | <span class='executed'>        if (allowance[from][msg.sender] != uint(-1)) {</span>
 75 |     | <span class='unexecuted'>            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);</span>
 76 |     | <span class='neutral'>        }</span>
 77 | *   | <span class='executed'>        _transfer(from, to, value);</span>
 78 | *   | <span class='executed'>        return true;</span>
 79 |     | <span class='neutral'>    }</span>
 80 |     | <span class='neutral'></span>
 81 |     | <span class='unexecuted'>    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {</span>
 82 |     | <span class='unexecuted'>        require(deadline &gt;= block.timestamp, &#39;UniswapV2: EXPIRED&#39;);</span>
 83 |     | <span class='unexecuted'>        bytes32 digest = keccak256(</span>
 84 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 85 |     | <span class='neutral'>                &#39;\x19\x01&#39;,</span>
 86 |     | <span class='unexecuted'>                DOMAIN_SEPARATOR,</span>
 87 |     | <span class='unexecuted'>                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))</span>
 88 |     | <span class='neutral'>            )</span>
 89 |     | <span class='neutral'>        );</span>
 90 |     | <span class='unexecuted'>        address recoveredAddress = ecrecover(digest, v, r, s);</span>
 91 |     | <span class='unexecuted'>        require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &#39;UniswapV2: INVALID_SIGNATURE&#39;);</span>
 92 |     | <span class='unexecuted'>        _approve(owner, spender, value);</span>
 93 |     | <span class='neutral'>    }</span>
 94 | *r  | <span class='executed'>    function mint(address account, uint amount) external {</span>
 95 | *r  | <span class='executed'>        _mint(account,amount);</span>
 96 |     | <span class='neutral'>    }</span>
 97 |     | <span class='neutral'>}</span>
 98 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/souravsuman/Documents/Personal/Echidna/6. uniswap periphery/contracts/uni-v2/UniswapV2Factory.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.6.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import &#39;../interfaces/IUniswapV2Factory.sol&#39;;</span>
  4 |     | <span class='neutral'>import &#39;./UniswapV2Pair.sol&#39;;</span>
  5 | *   | <span class='executed'></span>
  6 |     | <span class='neutral'>contract UniswapV2Factory is IUniswapV2Factory {</span>
  7 | *   | <span class='executed'>    address public override feeTo;</span>
  8 |     | <span class='unexecuted'>    address public override feeToSetter;</span>
  9 |     | <span class='neutral'></span>
 10 | *   | <span class='executed'>    mapping(address =&gt; mapping(address =&gt; address)) public override getPair;</span>
 11 |     | <span class='unexecuted'>    address[] public override allPairs;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    event PairCreated(address indexed token0, address indexed token1, address pair, uint);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    constructor(address _feeToSetter) public {</span>
 16 |     | <span class='unexecuted'>        feeToSetter = _feeToSetter;</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    function allPairsLength() external view override returns (uint) {</span>
 20 |     | <span class='unexecuted'>        return allPairs.length;</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function createPair(address tokenA, address tokenB) external override  returns (address pair) {</span>
 24 |     | <span class='unexecuted'>        require(tokenA != tokenB, &#39;UniswapV2: IDENTICAL_ADDRESSES&#39;);</span>
 25 |     | <span class='unexecuted'>        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span>
 26 |     | <span class='unexecuted'>        require(token0 != address(0), &#39;UniswapV2: ZERO_ADDRESS&#39;);</span>
 27 |     | <span class='unexecuted'>        require(getPair[token0][token1] == address(0), &#39;UniswapV2: PAIR_EXISTS&#39;); // single check is sufficient</span>
 28 |     | <span class='unexecuted'>        bytes memory bytecode = type(UniswapV2Pair).creationCode;</span>
 29 |     | <span class='unexecuted'>        bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span>
 30 |     | <span class='neutral'>        assembly {</span>
 31 |     | <span class='unexecuted'>            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)</span>
 32 |     | <span class='neutral'>        }</span>
 33 |     | <span class='unexecuted'>        IUniswapV2Pair(pair).initialize(token0, token1);</span>
 34 |     | <span class='unexecuted'>        getPair[token0][token1] = pair;</span>
 35 |     | <span class='unexecuted'>        getPair[token1][token0] = pair; // populate mapping in the reverse direction</span>
 36 |     | <span class='unexecuted'>        allPairs.push(pair);</span>
 37 |     | <span class='unexecuted'>        emit PairCreated(token0, token1, pair, allPairs.length);</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='unexecuted'>    function setFeeTo(address _feeTo) external override  {</span>
 41 |     | <span class='unexecuted'>        require(msg.sender == feeToSetter, &#39;UniswapV2: FORBIDDEN&#39;);</span>
 42 |     | <span class='unexecuted'>        feeTo = _feeTo;</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='unexecuted'>    function setFeeToSetter(address _feeToSetter) external override {</span>
 46 |     | <span class='unexecuted'>        require(msg.sender == feeToSetter, &#39;UniswapV2: FORBIDDEN&#39;);</span>
 47 |     | <span class='unexecuted'>        feeToSetter = _feeToSetter;</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'>}</span>
 50 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/souravsuman/Documents/Personal/Echidna/6. uniswap periphery/contracts/uni-v2/UniswapV2Pair.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity ^0.6.0;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>import &#39;../interfaces/IUniswapV2Pair.sol&#39;;</span>
   4 |     | <span class='neutral'>import &#39;./UniswapV2ERC20.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../libraries/Math.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../libraries/UQ112x112.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../interfaces/IERC20.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../interfaces/IUniswapV2Factory.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../interfaces/IUniswapV2Callee.sol&#39;;</span>
  10 | *r  | <span class='executed'></span>
  11 |     | <span class='neutral'>contract UniswapV2Pair is UniswapV2ERC20 {</span>
  12 |     | <span class='neutral'>    using SafeMath  for uint;</span>
  13 |     | <span class='neutral'>    using UQ112x112 for uint224;</span>
  14 |     | <span class='neutral'></span>
  15 | *   | <span class='executed'>    uint public constant MINIMUM_LIQUIDITY = 10**3;</span>
  16 | *   | <span class='executed'>    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(&#39;transfer(address,uint256)&#39;)));</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>    address public factory;</span>
  19 |     | <span class='unexecuted'>    address public token0;</span>
  20 |     | <span class='unexecuted'>    address public token1;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    uint112 private reserve0;           // uses single storage slot, accessible via getReserves</span>
  23 |     | <span class='neutral'>    uint112 private reserve1;           // uses single storage slot, accessible via getReserves</span>
  24 |     | <span class='neutral'>    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>    uint public price0CumulativeLast;</span>
  27 |     | <span class='unexecuted'>    uint public price1CumulativeLast;</span>
  28 |     | <span class='unexecuted'>    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>    uint private unlocked = 1;</span>
  31 |     | <span class='neutral'>    modifier lock() {</span>
  32 | *   | <span class='executed'>        require(unlocked == 1, &#39;UniswapV2: LOCKED&#39;);</span>
  33 | *   | <span class='executed'>        unlocked = 0;</span>
  34 | *   | <span class='executed'>        _;</span>
  35 | *   | <span class='executed'>        unlocked = 1;</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 | *r  | <span class='executed'>    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {</span>
  39 | *r  | <span class='executed'>        _reserve0 = reserve0;</span>
  40 | *r  | <span class='executed'>        _reserve1 = reserve1;</span>
  41 | *r  | <span class='executed'>        _blockTimestampLast = blockTimestampLast;</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 | *   | <span class='executed'>    function _safeTransfer(address token, address to, uint value) private {</span>
  45 | *   | <span class='executed'>        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));</span>
  46 | *   | <span class='executed'>        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#39;UniswapV2: TRANSFER_FAILED&#39;);</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    event Mint(address indexed sender, uint amount0, uint amount1);</span>
  50 |     | <span class='neutral'>    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);</span>
  51 |     | <span class='neutral'>    event Swap(</span>
  52 |     | <span class='neutral'>        address indexed sender,</span>
  53 |     | <span class='neutral'>        uint amount0In,</span>
  54 |     | <span class='neutral'>        uint amount1In,</span>
  55 |     | <span class='neutral'>        uint amount0Out,</span>
  56 |     | <span class='neutral'>        uint amount1Out,</span>
  57 |     | <span class='neutral'>        address indexed to</span>
  58 |     | <span class='neutral'>    );</span>
  59 |     | <span class='neutral'>    event Sync(uint112 reserve0, uint112 reserve1);</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>    constructor() public {</span>
  62 |     | <span class='unexecuted'>        factory = msg.sender;</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    // called once by the factory at time of deployment</span>
  66 |     | <span class='unexecuted'>    function initialize(address _token0, address _token1) external {</span>
  67 |     | <span class='unexecuted'>        require(msg.sender == factory, &#39;UniswapV2: FORBIDDEN&#39;); // sufficient check</span>
  68 |     | <span class='unexecuted'>        token0 = _token0;</span>
  69 |     | <span class='unexecuted'>        token1 = _token1;</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    // update reserves and, on the first call per block, price accumulators</span>
  73 | *   | <span class='executed'>    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {</span>
  74 | *   | <span class='executed'>        require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), &#39;UniswapV2: OVERFLOW&#39;);</span>
  75 | *   | <span class='executed'>        uint32 blockTimestamp = uint32(block.timestamp % 2**32);</span>
  76 | *   | <span class='executed'>        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired</span>
  77 | *   | <span class='executed'>        if (timeElapsed &gt; 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) {</span>
  78 |     | <span class='neutral'>            // * never overflows, and + overflow is desired</span>
  79 | *   | <span class='executed'>            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;</span>
  80 | *   | <span class='executed'>            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;</span>
  81 |     | <span class='neutral'>        }</span>
  82 | *   | <span class='executed'>        reserve0 = uint112(balance0);</span>
  83 | *   | <span class='executed'>        reserve1 = uint112(balance1);</span>
  84 | *   | <span class='executed'>        blockTimestampLast = blockTimestamp;</span>
  85 | *   | <span class='executed'>        emit Sync(reserve0, reserve1);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)</span>
  89 | *   | <span class='executed'>    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {</span>
  90 | *   | <span class='executed'>        address feeTo = IUniswapV2Factory(factory).feeTo();</span>
  91 | *   | <span class='executed'>        feeOn = feeTo != address(0);</span>
  92 | *   | <span class='executed'>        uint _kLast = kLast; // gas savings</span>
  93 | *   | <span class='executed'>        if (feeOn) {</span>
  94 |     | <span class='unexecuted'>            if (_kLast != 0) {</span>
  95 |     | <span class='unexecuted'>                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));</span>
  96 |     | <span class='unexecuted'>                uint rootKLast = Math.sqrt(_kLast);</span>
  97 |     | <span class='unexecuted'>                if (rootK &gt; rootKLast) {</span>
  98 |     | <span class='unexecuted'>                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));</span>
  99 |     | <span class='unexecuted'>                    uint denominator = rootK.mul(5).add(rootKLast);</span>
 100 |     | <span class='unexecuted'>                    uint liquidity = numerator / denominator;</span>
 101 |     | <span class='unexecuted'>                    if (liquidity &gt; 0) _mint(feeTo, liquidity);</span>
 102 |     | <span class='neutral'>                }</span>
 103 |     | <span class='neutral'>            }</span>
 104 | *   | <span class='executed'>        } else if (_kLast != 0) {</span>
 105 |     | <span class='unexecuted'>            kLast = 0;</span>
 106 |     | <span class='neutral'>        }</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    // this low-level function should be called from a contract which performs important safety checks</span>
 110 | *   | <span class='executed'>    function mint(address to) external lock returns (uint liquidity) {</span>
 111 | *   | <span class='executed'>        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings</span>
 112 | *   | <span class='executed'>        uint balance0 = IERC20(token0).balanceOf(address(this));</span>
 113 | *   | <span class='executed'>        uint balance1 = IERC20(token1).balanceOf(address(this));</span>
 114 | *   | <span class='executed'>        uint amount0 = balance0.sub(_reserve0);</span>
 115 | *   | <span class='executed'>        uint amount1 = balance1.sub(_reserve1);</span>
 116 |     | <span class='neutral'></span>
 117 | *   | <span class='executed'>        bool feeOn = _mintFee(_reserve0, _reserve1);</span>
 118 | *   | <span class='executed'>        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee</span>
 119 | *   | <span class='executed'>        if (_totalSupply == 0) {</span>
 120 | *   | <span class='executed'>            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);</span>
 121 | *   | <span class='executed'>           _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens</span>
 122 |     | <span class='neutral'>        } else {</span>
 123 | *   | <span class='executed'>            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);</span>
 124 |     | <span class='neutral'>        }</span>
 125 | *   | <span class='executed'>        require(liquidity &gt; 0, &#39;UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED&#39;);</span>
 126 | *   | <span class='executed'>        _mint(to, liquidity);</span>
 127 |     | <span class='neutral'></span>
 128 | *   | <span class='executed'>        _update(balance0, balance1, _reserve0, _reserve1);</span>
 129 | *   | <span class='executed'>        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date</span>
 130 | *   | <span class='executed'>        emit Mint(msg.sender, amount0, amount1);</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    // this low-level function should be called from a contract which performs important safety checks</span>
 134 | *   | <span class='executed'>    function burn(address to) external lock returns (uint amount0, uint amount1) {</span>
 135 | *   | <span class='executed'>        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings</span>
 136 | *   | <span class='executed'>        address _token0 = token0;                                // gas savings</span>
 137 | *   | <span class='executed'>        address _token1 = token1;                                // gas savings</span>
 138 | *   | <span class='executed'>        uint balance0 = IERC20(_token0).balanceOf(address(this));</span>
 139 | *   | <span class='executed'>        uint balance1 = IERC20(_token1).balanceOf(address(this));</span>
 140 | *   | <span class='executed'>        uint liquidity = balanceOf[address(this)];</span>
 141 |     | <span class='neutral'></span>
 142 | *   | <span class='executed'>        bool feeOn = _mintFee(_reserve0, _reserve1);</span>
 143 | *   | <span class='executed'>        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee</span>
 144 | *   | <span class='executed'>        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution</span>
 145 | *   | <span class='executed'>        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution</span>
 146 | *   | <span class='executed'>        require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, &#39;UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED&#39;);</span>
 147 | *   | <span class='executed'>        _burn(address(this), liquidity);</span>
 148 | *   | <span class='executed'>        _safeTransfer(_token0, to, amount0);</span>
 149 | *   | <span class='executed'>        _safeTransfer(_token1, to, amount1);</span>
 150 | *   | <span class='executed'>        balance0 = IERC20(_token0).balanceOf(address(this));</span>
 151 | *   | <span class='executed'>        balance1 = IERC20(_token1).balanceOf(address(this));</span>
 152 |     | <span class='neutral'></span>
 153 | *   | <span class='executed'>        _update(balance0, balance1, _reserve0, _reserve1);</span>
 154 | *   | <span class='executed'>        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date</span>
 155 | *   | <span class='executed'>        emit Burn(msg.sender, amount0, amount1, to);</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    // this low-level function should be called from a contract which performs important safety checks</span>
 159 | *   | <span class='executed'>    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {</span>
 160 | *   | <span class='executed'>        require(amount0Out &gt; 0 || amount1Out &gt; 0, &#39;UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT&#39;);</span>
 161 | *   | <span class='executed'>        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings</span>
 162 | *   | <span class='executed'>        require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, &#39;UniswapV2: INSUFFICIENT_LIQUIDITY&#39;);</span>
 163 |     | <span class='neutral'></span>
 164 | *   | <span class='executed'>        uint balance0;</span>
 165 | *   | <span class='executed'>        uint balance1;</span>
 166 |     | <span class='neutral'>        { // scope for _token{0,1}, avoids stack too deep errors</span>
 167 | *   | <span class='executed'>        address _token0 = token0;</span>
 168 | *   | <span class='executed'>        address _token1 = token1;</span>
 169 | *   | <span class='executed'>        require(to != _token0 &amp;&amp; to != _token1, &#39;UniswapV2: INVALID_TO&#39;);</span>
 170 | *   | <span class='executed'>        if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens</span>
 171 | *   | <span class='executed'>        if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens</span>
 172 | *   | <span class='executed'>        if (data.length &gt; 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);</span>
 173 | *   | <span class='executed'>        balance0 = IERC20(_token0).balanceOf(address(this));</span>
 174 | *   | <span class='executed'>        balance1 = IERC20(_token1).balanceOf(address(this));</span>
 175 |     | <span class='neutral'>        }</span>
 176 | *   | <span class='executed'>        uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;</span>
 177 | *   | <span class='executed'>        uint amount1In = balance1 &gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;</span>
 178 | *   | <span class='executed'>        require(amount0In &gt; 0 || amount1In &gt; 0, &#39;UniswapV2: INSUFFICIENT_INPUT_AMOUNT&#39;);</span>
 179 |     | <span class='neutral'>        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors</span>
 180 | *   | <span class='executed'>        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));</span>
 181 | *   | <span class='executed'>        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));</span>
 182 | *   | <span class='executed'>        require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), &#39;UniswapV2: K&#39;);</span>
 183 |     | <span class='neutral'>        }</span>
 184 |     | <span class='neutral'></span>
 185 | *   | <span class='executed'>        _update(balance0, balance1, _reserve0, _reserve1);</span>
 186 | *   | <span class='executed'>        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>    // force balances to match reserves</span>
 190 |     | <span class='unexecuted'>    function skim(address to) external lock {</span>
 191 |     | <span class='unexecuted'>        address _token0 = token0; // gas savings</span>
 192 |     | <span class='unexecuted'>        address _token1 = token1; // gas savings</span>
 193 |     | <span class='unexecuted'>        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));</span>
 194 |     | <span class='unexecuted'>        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));</span>
 195 |     | <span class='neutral'>    }</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>    // force reserves to match balances</span>
 198 |     | <span class='unexecuted'>    function sync() external lock {</span>
 199 |     | <span class='unexecuted'>        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'>}</span>
 202 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/souravsuman/Documents/Personal/Echidna/6. uniswap periphery/contracts/uni-v2/UniswapV2Router01.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity =0.6.6;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>import &#39;../interfaces/IUniswapV2Factory.sol&#39;;</span>
   4 |     | <span class='neutral'>import &#39;../libraries/TransferHelper.sol&#39;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &#39;../libraries/UniswapV2Library.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../interfaces/IUniswapV2Router01.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../interfaces/IERC20.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../interfaces/IWETH.sol&#39;;</span>
  10 | *   | <span class='executed'></span>
  11 |     | <span class='neutral'>contract UniswapV2Router01 is IUniswapV2Router01 {</span>
  12 |     | <span class='unexecuted'>    address public immutable override factory;</span>
  13 |     | <span class='unexecuted'>    address public immutable override WETH;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    modifier ensure(uint deadline) {</span>
  16 | *   | <span class='executed'>        require(deadline &gt;= block.timestamp, &#39;UniswapV2Router: EXPIRED&#39;);</span>
  17 | *   | <span class='executed'>        _;</span>
  18 |     | <span class='neutral'>    }</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    constructor(address _factory, address _WETH) public {</span>
  21 |     | <span class='unexecuted'>        factory = _factory;</span>
  22 |     | <span class='unexecuted'>        WETH = _WETH;</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    receive() external payable {</span>
  26 |     | <span class='unexecuted'>        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract</span>
  27 |     | <span class='neutral'>    }</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    // **** ADD LIQUIDITY ****</span>
  30 | *   | <span class='executed'>    function _addLiquidity(</span>
  31 |     | <span class='neutral'>        address tokenA,</span>
  32 |     | <span class='neutral'>        address tokenB,</span>
  33 |     | <span class='neutral'>        uint amountADesired,</span>
  34 |     | <span class='neutral'>        uint amountBDesired,</span>
  35 |     | <span class='neutral'>        uint amountAMin,</span>
  36 |     | <span class='neutral'>        uint amountBMin</span>
  37 | *   | <span class='executed'>    ) private returns (uint amountA, uint amountB) {</span>
  38 |     | <span class='neutral'>        // create the pair if it doesn&#39;t exist yet</span>
  39 | *   | <span class='executed'>        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {</span>
  40 |     | <span class='unexecuted'>            IUniswapV2Factory(factory).createPair(tokenA, tokenB);</span>
  41 |     | <span class='neutral'>        }</span>
  42 | *   | <span class='executed'>        (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);</span>
  43 | *   | <span class='executed'>        if (reserveA == 0 &amp;&amp; reserveB == 0) {</span>
  44 | *   | <span class='executed'>            (amountA, amountB) = (amountADesired, amountBDesired);</span>
  45 |     | <span class='neutral'>        } else {</span>
  46 | *   | <span class='executed'>            uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);</span>
  47 | *   | <span class='executed'>            if (amountBOptimal &lt;= amountBDesired) {</span>
  48 | *   | <span class='executed'>                require(amountBOptimal &gt;= amountBMin, &#39;UniswapV2Router: INSUFFICIENT_B_AMOUNT&#39;);</span>
  49 | *   | <span class='executed'>                (amountA, amountB) = (amountADesired, amountBOptimal);</span>
  50 |     | <span class='neutral'>            } else {</span>
  51 | *   | <span class='executed'>                uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);</span>
  52 | *   | <span class='executed'>                assert(amountAOptimal &lt;= amountADesired);</span>
  53 | *   | <span class='executed'>                require(amountAOptimal &gt;= amountAMin, &#39;UniswapV2Router: INSUFFICIENT_A_AMOUNT&#39;);</span>
  54 | *   | <span class='executed'>                (amountA, amountB) = (amountAOptimal, amountBDesired);</span>
  55 |     | <span class='neutral'>            }</span>
  56 |     | <span class='neutral'>        }</span>
  57 |     | <span class='neutral'>    }</span>
  58 | *   | <span class='executed'>    function addLiquidity(</span>
  59 |     | <span class='neutral'>        address tokenA,</span>
  60 |     | <span class='neutral'>        address tokenB,</span>
  61 |     | <span class='neutral'>        uint amountADesired,</span>
  62 |     | <span class='neutral'>        uint amountBDesired,</span>
  63 |     | <span class='neutral'>        uint amountAMin,</span>
  64 |     | <span class='neutral'>        uint amountBMin,</span>
  65 |     | <span class='neutral'>        address to,</span>
  66 |     | <span class='neutral'>        uint deadline</span>
  67 | *   | <span class='executed'>    ) external override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {</span>
  68 | *   | <span class='executed'>        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);</span>
  69 | *   | <span class='executed'>        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);</span>
  70 | *   | <span class='executed'>        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);</span>
  71 | *   | <span class='executed'>        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);</span>
  72 | *   | <span class='executed'>        liquidity = IUniswapV2Pair(pair).mint(to);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='unexecuted'>    function addLiquidityETH(</span>
  75 |     | <span class='neutral'>        address token,</span>
  76 |     | <span class='neutral'>        uint amountTokenDesired,</span>
  77 |     | <span class='neutral'>        uint amountTokenMin,</span>
  78 |     | <span class='neutral'>        uint amountETHMin,</span>
  79 |     | <span class='neutral'>        address to,</span>
  80 |     | <span class='neutral'>        uint deadline</span>
  81 |     | <span class='unexecuted'>    ) external override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {</span>
  82 |     | <span class='unexecuted'>        (amountToken, amountETH) = _addLiquidity(</span>
  83 |     | <span class='unexecuted'>            token,</span>
  84 |     | <span class='unexecuted'>            WETH,</span>
  85 |     | <span class='unexecuted'>            amountTokenDesired,</span>
  86 |     | <span class='unexecuted'>            msg.value,</span>
  87 |     | <span class='unexecuted'>            amountTokenMin,</span>
  88 |     | <span class='unexecuted'>            amountETHMin</span>
  89 |     | <span class='neutral'>        );</span>
  90 |     | <span class='unexecuted'>        address pair = UniswapV2Library.pairFor(factory, token, WETH);</span>
  91 |     | <span class='unexecuted'>        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);</span>
  92 |     | <span class='unexecuted'>        IWETH(WETH).deposit{value: amountETH}();</span>
  93 |     | <span class='unexecuted'>        assert(IWETH(WETH).transfer(pair, amountETH));</span>
  94 |     | <span class='unexecuted'>        liquidity = IUniswapV2Pair(pair).mint(to);</span>
  95 |     | <span class='unexecuted'>        if (msg.value &gt; amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH); // refund dust eth, if any</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    // **** REMOVE LIQUIDITY ****</span>
  99 | *   | <span class='executed'>    function removeLiquidity(</span>
 100 |     | <span class='neutral'>        address tokenA,</span>
 101 |     | <span class='neutral'>        address tokenB,</span>
 102 |     | <span class='neutral'>        uint liquidity,</span>
 103 |     | <span class='neutral'>        uint amountAMin,</span>
 104 |     | <span class='neutral'>        uint amountBMin,</span>
 105 |     | <span class='neutral'>        address to,</span>
 106 |     | <span class='neutral'>        uint deadline</span>
 107 | *   | <span class='executed'>    ) public override ensure(deadline) returns (uint amountA, uint amountB) {</span>
 108 | *   | <span class='executed'>        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);</span>
 109 | *   | <span class='executed'>        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair</span>
 110 | *   | <span class='executed'>        (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);</span>
 111 | *   | <span class='executed'>        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);</span>
 112 | *   | <span class='executed'>        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);</span>
 113 | *   | <span class='executed'>        require(amountA &gt;= amountAMin, &#39;UniswapV2Router: INSUFFICIENT_A_AMOUNT&#39;);</span>
 114 | *   | <span class='executed'>        require(amountB &gt;= amountBMin, &#39;UniswapV2Router: INSUFFICIENT_B_AMOUNT&#39;);</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='unexecuted'>    function removeLiquidityETH(</span>
 117 |     | <span class='neutral'>        address token,</span>
 118 |     | <span class='neutral'>        uint liquidity,</span>
 119 |     | <span class='neutral'>        uint amountTokenMin,</span>
 120 |     | <span class='neutral'>        uint amountETHMin,</span>
 121 |     | <span class='neutral'>        address to,</span>
 122 |     | <span class='neutral'>        uint deadline</span>
 123 |     | <span class='unexecuted'>    ) public override ensure(deadline) returns (uint amountToken, uint amountETH) {</span>
 124 |     | <span class='unexecuted'>        (amountToken, amountETH) = removeLiquidity(</span>
 125 |     | <span class='unexecuted'>            token,</span>
 126 |     | <span class='unexecuted'>            WETH,</span>
 127 |     | <span class='unexecuted'>            liquidity,</span>
 128 |     | <span class='unexecuted'>            amountTokenMin,</span>
 129 |     | <span class='unexecuted'>            amountETHMin,</span>
 130 |     | <span class='unexecuted'>            address(this),</span>
 131 |     | <span class='unexecuted'>            deadline</span>
 132 |     | <span class='neutral'>        );</span>
 133 |     | <span class='unexecuted'>        TransferHelper.safeTransfer(token, to, amountToken);</span>
 134 |     | <span class='unexecuted'>        IWETH(WETH).withdraw(amountETH);</span>
 135 |     | <span class='unexecuted'>        TransferHelper.safeTransferETH(to, amountETH);</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='unexecuted'>    function removeLiquidityWithPermit(</span>
 138 |     | <span class='neutral'>        address tokenA,</span>
 139 |     | <span class='neutral'>        address tokenB,</span>
 140 |     | <span class='neutral'>        uint liquidity,</span>
 141 |     | <span class='neutral'>        uint amountAMin,</span>
 142 |     | <span class='neutral'>        uint amountBMin,</span>
 143 |     | <span class='neutral'>        address to,</span>
 144 |     | <span class='neutral'>        uint deadline,</span>
 145 |     | <span class='neutral'>        bool approveMax, uint8 v, bytes32 r, bytes32 s</span>
 146 |     | <span class='unexecuted'>    ) external override returns (uint amountA, uint amountB) {</span>
 147 |     | <span class='unexecuted'>        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);</span>
 148 |     | <span class='unexecuted'>        uint value = approveMax ? uint(-1) : liquidity;</span>
 149 |     | <span class='unexecuted'>        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);</span>
 150 |     | <span class='unexecuted'>        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='unexecuted'>    function removeLiquidityETHWithPermit(</span>
 153 |     | <span class='neutral'>        address token,</span>
 154 |     | <span class='neutral'>        uint liquidity,</span>
 155 |     | <span class='neutral'>        uint amountTokenMin,</span>
 156 |     | <span class='neutral'>        uint amountETHMin,</span>
 157 |     | <span class='neutral'>        address to,</span>
 158 |     | <span class='neutral'>        uint deadline,</span>
 159 |     | <span class='neutral'>        bool approveMax, uint8 v, bytes32 r, bytes32 s</span>
 160 |     | <span class='unexecuted'>    ) external override returns (uint amountToken, uint amountETH) {</span>
 161 |     | <span class='unexecuted'>        address pair = UniswapV2Library.pairFor(factory, token, WETH);</span>
 162 |     | <span class='unexecuted'>        uint value = approveMax ? uint(-1) : liquidity;</span>
 163 |     | <span class='unexecuted'>        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);</span>
 164 |     | <span class='unexecuted'>        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    // **** SWAP ****</span>
 168 |     | <span class='neutral'>    // requires the initial amount to have already been sent to the first pair</span>
 169 | *   | <span class='executed'>    function _swap(uint[] memory amounts, address[] memory path, address _to) private {</span>
 170 | *   | <span class='executed'>        for (uint i; i &lt; path.length - 1; i++) {</span>
 171 | *   | <span class='executed'>            (address input, address output) = (path[i], path[i + 1]);</span>
 172 | *   | <span class='executed'>            (address token0,) = UniswapV2Library.sortTokens(input, output);</span>
 173 | *   | <span class='executed'>            uint amountOut = amounts[i + 1];</span>
 174 | *   | <span class='executed'>            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));</span>
 175 | *   | <span class='executed'>            address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;</span>
 176 | *   | <span class='executed'>            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(amount0Out, amount1Out, to, new bytes(0));</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>    }</span>
 179 | *   | <span class='executed'>    function swapExactTokensForTokens(</span>
 180 |     | <span class='neutral'>        uint amountIn,</span>
 181 |     | <span class='neutral'>        uint amountOutMin,</span>
 182 |     | <span class='neutral'>        address[] calldata path,</span>
 183 |     | <span class='neutral'>        address to,</span>
 184 |     | <span class='neutral'>        uint deadline</span>
 185 | *   | <span class='executed'>    ) external override ensure(deadline) returns (uint[] memory amounts) {</span>
 186 | *   | <span class='executed'>        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);</span>
 187 | *   | <span class='executed'>        require(amounts[amounts.length - 1] &gt;= amountOutMin, &#39;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#39;);</span>
 188 | *   | <span class='executed'>        TransferHelper.safeTransferFrom(path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]);</span>
 189 | *   | <span class='executed'>        _swap(amounts, path, to);</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='unexecuted'>    function swapTokensForExactTokens(</span>
 192 |     | <span class='neutral'>        uint amountOut,</span>
 193 |     | <span class='neutral'>        uint amountInMax,</span>
 194 |     | <span class='neutral'>        address[] calldata path,</span>
 195 |     | <span class='neutral'>        address to,</span>
 196 |     | <span class='neutral'>        uint deadline</span>
 197 |     | <span class='unexecuted'>    ) external override ensure(deadline) returns (uint[] memory amounts) {</span>
 198 |     | <span class='unexecuted'>        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);</span>
 199 |     | <span class='unexecuted'>        require(amounts[0] &lt;= amountInMax, &#39;UniswapV2Router: EXCESSIVE_INPUT_AMOUNT&#39;);</span>
 200 |     | <span class='unexecuted'>        TransferHelper.safeTransferFrom(path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]);</span>
 201 |     | <span class='unexecuted'>        _swap(amounts, path, to);</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='unexecuted'>    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)</span>
 204 |     | <span class='neutral'>        external</span>
 205 |     | <span class='neutral'>        override</span>
 206 |     | <span class='neutral'>        payable</span>
 207 |     | <span class='unexecuted'>        ensure(deadline)</span>
 208 |     | <span class='unexecuted'>        returns (uint[] memory amounts)</span>
 209 |     | <span class='neutral'>    {</span>
 210 |     | <span class='unexecuted'>        require(path[0] == WETH, &#39;UniswapV2Router: INVALID_PATH&#39;);</span>
 211 |     | <span class='unexecuted'>        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);</span>
 212 |     | <span class='unexecuted'>        require(amounts[amounts.length - 1] &gt;= amountOutMin, &#39;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#39;);</span>
 213 |     | <span class='unexecuted'>        IWETH(WETH).deposit{value: amounts[0]}();</span>
 214 |     | <span class='unexecuted'>        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));</span>
 215 |     | <span class='unexecuted'>        _swap(amounts, path, to);</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='unexecuted'>    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)</span>
 218 |     | <span class='neutral'>        external</span>
 219 |     | <span class='neutral'>        override</span>
 220 |     | <span class='unexecuted'>        ensure(deadline)</span>
 221 |     | <span class='unexecuted'>        returns (uint[] memory amounts)</span>
 222 |     | <span class='neutral'>    {</span>
 223 |     | <span class='unexecuted'>        require(path[path.length - 1] == WETH, &#39;UniswapV2Router: INVALID_PATH&#39;);</span>
 224 |     | <span class='unexecuted'>        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);</span>
 225 |     | <span class='unexecuted'>        require(amounts[0] &lt;= amountInMax, &#39;UniswapV2Router: EXCESSIVE_INPUT_AMOUNT&#39;);</span>
 226 |     | <span class='unexecuted'>        TransferHelper.safeTransferFrom(path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]);</span>
 227 |     | <span class='unexecuted'>        _swap(amounts, path, address(this));</span>
 228 |     | <span class='unexecuted'>        IWETH(WETH).withdraw(amounts[amounts.length - 1]);</span>
 229 |     | <span class='unexecuted'>        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='unexecuted'>    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)</span>
 232 |     | <span class='neutral'>        external</span>
 233 |     | <span class='neutral'>        override</span>
 234 |     | <span class='unexecuted'>        ensure(deadline)</span>
 235 |     | <span class='unexecuted'>        returns (uint[] memory amounts)</span>
 236 |     | <span class='neutral'>    {</span>
 237 |     | <span class='unexecuted'>        require(path[path.length - 1] == WETH, &#39;UniswapV2Router: INVALID_PATH&#39;);</span>
 238 |     | <span class='unexecuted'>        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);</span>
 239 |     | <span class='unexecuted'>        require(amounts[amounts.length - 1] &gt;= amountOutMin, &#39;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&#39;);</span>
 240 |     | <span class='unexecuted'>        TransferHelper.safeTransferFrom(path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]);</span>
 241 |     | <span class='unexecuted'>        _swap(amounts, path, address(this));</span>
 242 |     | <span class='unexecuted'>        IWETH(WETH).withdraw(amounts[amounts.length - 1]);</span>
 243 |     | <span class='unexecuted'>        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);</span>
 244 |     | <span class='neutral'>    }</span>
 245 |     | <span class='unexecuted'>    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)</span>
 246 |     | <span class='neutral'>        external</span>
 247 |     | <span class='neutral'>        override</span>
 248 |     | <span class='neutral'>        payable</span>
 249 |     | <span class='unexecuted'>        ensure(deadline)</span>
 250 |     | <span class='unexecuted'>        returns (uint[] memory amounts)</span>
 251 |     | <span class='neutral'>    {</span>
 252 |     | <span class='unexecuted'>        require(path[0] == WETH, &#39;UniswapV2Router: INVALID_PATH&#39;);</span>
 253 |     | <span class='unexecuted'>        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);</span>
 254 |     | <span class='unexecuted'>        require(amounts[0] &lt;= msg.value, &#39;UniswapV2Router: EXCESSIVE_INPUT_AMOUNT&#39;);</span>
 255 |     | <span class='unexecuted'>        IWETH(WETH).deposit{value: amounts[0]}();</span>
 256 |     | <span class='unexecuted'>        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));</span>
 257 |     | <span class='unexecuted'>        _swap(amounts, path, to);</span>
 258 |     | <span class='unexecuted'>        if (msg.value &gt; amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]); // refund dust eth, if any</span>
 259 |     | <span class='neutral'>    }</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='unexecuted'>    function quote(uint amountA, uint reserveA, uint reserveB) public pure override returns (uint amountB) {</span>
 262 |     | <span class='unexecuted'>        return UniswapV2Library.quote(amountA, reserveA, reserveB);</span>
 263 |     | <span class='neutral'>    }</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='unexecuted'>    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) public pure override returns (uint amountOut) {</span>
 266 |     | <span class='unexecuted'>        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);</span>
 267 |     | <span class='neutral'>    }</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='unexecuted'>    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) public pure override returns (uint amountIn) {</span>
 270 |     | <span class='unexecuted'>        return UniswapV2Library.getAmountOut(amountOut, reserveIn, reserveOut);</span>
 271 |     | <span class='neutral'>    }</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='unexecuted'>    function getAmountsOut(uint amountIn, address[] memory path) public view override returns (uint[] memory amounts) {</span>
 274 |     | <span class='unexecuted'>        return UniswapV2Library.getAmountsOut(factory, amountIn, path);</span>
 275 |     | <span class='neutral'>    }</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='unexecuted'>    function getAmountsIn(uint amountOut, address[] memory path) public view override returns (uint[] memory amounts) {</span>
 278 |     | <span class='unexecuted'>        return UniswapV2Library.getAmountsIn(factory, amountOut, path);</span>
 279 |     | <span class='neutral'>    }</span>
 280 |     | <span class='neutral'>}</span>

</code>
<br />

